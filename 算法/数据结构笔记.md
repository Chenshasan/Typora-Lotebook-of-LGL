# 数据结构笔记

### 链表：

- List：线性表（每个元素的类型必须相同）——list基本操作与java中ArrayList基本相同
- simple array implementation of list——insert/removing
- Linked List——在java中由引用来使用link(link中的remove直接改变指针的指向即可)

![1570868249592](数据结构笔记.assets/1570868249592.png)

listnode 代码

![1570868361254](数据结构笔记.assets/1570868361254.png)

linkedListItr 链表游标——当前指针指向

![1570868563569](数据结构笔记.assets/1570868563569.png)

linkedList类只含有一个全局变量，为header，若为带表头节点，则header指向表头节点，若为不带表头节点，则header指向第一个数据节点

通过游标遍历单链表：

![1570868832275](数据结构笔记.assets/1570868832275.png)

双向链表：每个节点有两个指针，一个指针指向上一个节点，一个指针指向下一个节点，能够平均提升一倍的速度，但增加内存消耗

![1570870319222](数据结构笔记.assets/1570870319222.png)

循环链表：最后一个指针指向第一个节点

![1570870769200](数据结构笔记.assets/1570870769200.png)

##### 约瑟夫问题：

循环单链表=>每走m个next则将所在的次序退出，且输出该节点的序号=>到最后一个节点时结束

##### 多项式表示方法：

1. 用数组表示，每个数组单元的Index为多项式的次方，里面的值为多项式该次方的系数

   加法：

   ![1571042202701](数据结构笔记.assets/1571042202701.png)

   乘法：

   ![1571042225921](数据结构笔记.assets/1571042225921.png)

2. 用链表表示

   加法操作：

   ![1571042697280](数据结构笔记.assets/1571042697280.png)

##### 静态链表：

链表的连接方式由程序员管理（管理内存所有空间）

![1571045981417](数据结构笔记.assets/1571045981417.png)

- 初始化：将所有数据块串成单链表
- 分配内存：分配内存给对象后，将分配的内从从单链表中去除

##### 基数排序：

先把个位排序，通过链表储存，先进先出后，再把十位排序，把百位排序（同样方法），完成最终排序

![1571046777151](数据结构笔记.assets/1571046777151.png)

### 栈：

#### 单链表：尾部为栈底，头部为栈顶

![1571292764132](数据结构笔记.assets/1571292764132.png)

pick操作，取出数据，删掉top数据

![1571293099675](数据结构笔记.assets/1571293099675.png)

#### 数组实现栈：

![1571293233633](数据结构笔记.assets/1571293233633.png)

- 当有两个栈时，可以用同一块内存空间来放两个栈，一个起点为数组0位，一个起点为数组末端

#### 应用：括号matching 

基本逻辑为将左括号先push进栈中，然后遇到右括号时，将最近的一个左括号和此右括号进行匹配，匹配完即可

![1571296006155](数据结构笔记.assets/1571296006155.png)

#### 应用：expression evaluation

- 中缀表达式和后缀表达式：操作符出现在操作数的中间和末尾

- 后缀表达式，不需要写括号，可直接通过栈处理

- 遇到操作数就直接进栈，遇到后缀操作符就取出两个值计算，计算完了之后再进栈

  ![1571297779697](数据结构笔记.assets/1571297779697.png)

- 中缀表达式怎么转后缀表达式：

  ![1571297841673](数据结构笔记.assets/1571297841673.png)

  ![1571297866713](数据结构笔记.assets/1571297866713.png)
  
  （遇到操作数直接输出而遇到操作符不输出是因为操作符的另一半还没有被扫描到）
  
  （对于'('如果在栈中，则优先级为低优先级（为了防止提早弹出），但如果‘（’为当前符号，则为高优先级（防止栈中符号弹出））
  
  ![1571646452649](数据结构笔记.assets/1571646452649.png)
  
  （对于所有的‘）’都弹到知道遇到‘（’，如果不是的话则比较优先级选择是否弹出，‘（’有两个优先级，然后直到当前的符号的优先级大于栈顶的优先级，再将最后pop出的栈顶元素压栈，当前元素压栈）
  
  

### 队列：

#### 队列的进队与出队：

- 出队：back=back+1 front=front+1都是O（1）的复杂度

- ![1571647205682](数据结构笔记.assets/1571647205682.png)

  将数组变为一个圈，实现方法为：

  ![1571647274053](数据结构笔记.assets/1571647274053.png)

#### 应用：队列打印杨辉三角

![1571650055480](数据结构笔记.assets/1571650055480.png)

（基本逻辑为：保证每一行的数都进入，然后打印出下一行的值，同时将下一行的值储存进队列中，最后打印成整个三角）

（不用队列实现时直接用二维数组实现，每一行的某个数字由上一行的对应数字相加而来）

#### 应用：路径寻找

主要分为两个过程，第一个过程为从a开始寻找到b的路径，按照到a的距离标号，然后从b开始回溯，每一次都找标号更小的位置

![1571651888469](数据结构笔记.assets/1571651888469.png)

![1571651971184](数据结构笔记.assets/1571651971184.png)

基本逻辑为：不断的在队列当中增加格子，当一个格子的所有四个方向已经全部被搜索完之后，删除队列中的该格子，然后再将视角换位下个队列中的格子，直到到达最后的终点

![1571651983491](数据结构笔记.assets/1571651983491.png)

![1571651997793](数据结构笔记.assets/1571651997793.png)

### 树：

#### 定义：

空树/树根+子树

degree of the node:the children is has

degree of the tree:the maximum of the degree of node in the tree

leaf/branch:the degree is 0/not 0

level:the root :0 		the elelment:the level of its parent +1

depth of the tree:the maximum of the level

#### Binary tree:

根节点+每个节点有左树和右树

##### 二叉树性质：

1. 二叉树有N个节点的时候，必然有N-1条边
2. 二叉树的第i层最多有2的i次方个节点
3. 二叉树高度为h，最少的节点数为h+1,最多的节点数为2<sup>h+1</sup>-1
4. 二叉树的叶的个数为n，二叉树中度为2的节点个数为n<sub>2</sub>,则有n=n<sub>2</sub>+1
5. 如果一个二叉树含有N个节点，高度最多为N-1,最少为[log<sub>2</sub>(n+1)]-1

##### 满二叉树：

高度为h时，节点数为2<sup>h+1</sup>-1

满二叉树标号：从高到低，从左到右递增

##### 完全二叉树：

对于满二叉树从标号的最后开始删除节点，得到的树为完全二叉树

###### 性质：

1. 完全二叉树中，对于任意i>0，其父节点的标号为[(i-1)/2]
2. 对于一个节点，其左子节点的标号为2i+1，如果2i+1>=n，则没有左子节点

##### 二叉树的实现：

1. 数组实现完全二叉树：按照标号储存进数组（调用左子节点和右子节点是通过2i+1,2i+2）

2. 非完全二叉树：在完全二叉树的表示中空出对应的节点

3. 链表表示二叉树

   ![image-20191028165825988](数据结构笔记.assets/image-20191028165825988.png)

##### 二叉树的基本实现：

![image-20191028173728513](数据结构笔记.assets/image-20191028173728513.png)

###### 二叉树创建：

![image-20191028173803601](数据结构笔记.assets/image-20191028173803601.png)

###### 遍历二叉树：

<img src="数据结构笔记.assets/image-20191028173902893.png" alt="image-20191028173902893" style="zoom:80%;" />

VLR,LVR,LRV（递归访问）

preorder,inorder,postorder，level order

preorder:

<img src="数据结构笔记.assets/image-20191028175002457.png" alt="image-20191028175002457" style="zoom: 33%;" />

inorder:

<img src="数据结构笔记.assets/image-20191028175033869.png" alt="image-20191028175033869" style="zoom:33%;" />

postorder类似

level order：

如果按数组方式实现：则直接下标递增再访问即可

如果按链表实现队列：FIFO队列，上一层先进入，在下一层使用时调用上一层的子节点，再将上一层节点排出，下一层节点进入

<img src="数据结构笔记.assets/image-20191028175533974.png" alt="image-20191028175533974" style="zoom:67%;" />

使用非递归方法实现中序遍历：

基本逻辑为：直到最左边的左子树为空的时候对于该节点，输出它的值，然后p调用他的右子树，重复这一过程。

![image-20191031141426008](数据结构笔记.assets/image-20191031141426008.png)

使用非递归方法使用后序遍历：

基本逻辑为：P不为空时，一直将p导入进p的左子树，直到左子树为空，判断这个节点是不是右子树遍历完才回来的，如果是，则处理掉这个节点，同时调用他的上一个节点，直到上层节点的该节点是从左子树返回的，再将p指为其右子树，并将该节点设成tag为一。

![image-20191031142400612](数据结构笔记.assets/image-20191031142400612.png)

###### 如何建立二叉树：

- 利用先序，中序唯一构造二叉树

  ![image-20191031145121617](数据结构笔记.assets/image-20191031145121617.png)

- 利用二叉树的广义表示来构造一棵二叉树

  ![image-20191031145143547](数据结构笔记.assets/image-20191031145143547.png)

- 利用二叉树的后缀表示来表示一棵二叉树

  ![image-20191031145201289](数据结构笔记.assets/image-20191031145201289.png)



通过先序遍历和中序遍历的字符串构建二叉树：

- 基本逻辑为：通过先序遍历串确定树根，然后将t的左子树进行递归，将t的右子树进行递归
- 通过先序遍历和后序遍历/中序遍历和后序遍历也可以构建二叉树
- 通过这些方式构建的二叉树可能不唯一

![image-20191104161827611](数据结构笔记.assets/image-20191104161827611.png)

##### 二叉树应用

###### 树的储存方式：

- 广义表示法为括号中为其子节点
- 双亲表示法为一个元素的element的值为其父节点
- 左子女——右兄弟表示法为左节点即为其子节点，其height加一，右节点为平行节点

![image-20191104163110382](数据结构笔记.assets/image-20191104163110382.png)

###### 左子女右兄弟表示法的实现：

添加节点

遍历到其父节点，如果其父节点没有有左节点，则将该节点添加到其左节点，如果其父节点有左节点，则将从左节点开始沿着右节点走，直到最后，添加该节点

![image-20191104163935056](数据结构笔记.assets/image-20191104163935056.png)

###### 创建多棵树：

先将各个树通过“左子女——右兄弟”的表示方法排列，再将其通过根节点的右节点联系起来

###### 树的遍历：

1. 深度优先遍历

   - 先序优先遍历

   - 后序优先遍历（后序遍历的顺序和将该树转化为左子女右兄弟之后的二叉树的中序遍历顺序相同）

2. 广度优先遍历

   宽度有限：先将每一层的所有节点遍历完，再深入下一层

###### 森林的遍历：

将森林转化为左子女右兄弟的二叉树，然后遍历二叉树

![image-20191104165818571](数据结构笔记.assets/image-20191104165818571.png)

###### Thread Tree：线索化树

希望给节点一个额外的数据，直接指向中序遍历或者先序遍历的下一个节点，不需要用递归实现

- n个节点有2n个链域，且实际使用的只有n-1个链域

- 将右节点为null的设为中序遍历下一个节点的指针，左节点为null的设为中序遍历上一个节点的指针

- 需要标记——是原节点的指针还是中序遍历的指针（增加标记域）

  ![image-20191104172658989](数据结构笔记.assets/image-20191104172658989.png)

- 中序线索化树的遍历：如果有线索，就根据其线索走，如果没有线索，则找其右节点的最左节点即可

  ![image-20191104173719258](数据结构笔记.assets/image-20191104173719258.png)

  ![image-20191104173745799](数据结构笔记.assets/image-20191104173745799.png)

- 对于已知二叉树构建中序遍历线索树

  将其通过中序遍历，但要保留一个pre游标，游标中始终为该节点的中序遍历前一个节点的指针，当左节点为null时，填充pre

###### 霍夫曼树：

1. 增长数的概念
   - 使二叉树的所有节点度数为2，新增加的全为叶节点，新增加的全为外节点，原来的节点全为内节点
   - 外通路的长度：根节点到每个叶节点的长度的总和
   - 内通路的长度：根节点到原树的长度的总和
   - 带权重的通路长度：每个节点可以设置权重，再来算通路的总长度
2. 霍夫曼树的目标：构建一个加权的外通路长度最短的树（给了叶节点的数量，对于一棵完全二叉树，其所有节点的数量是固定的）
3. 霍夫曼树的算法：
   - 先将权重从小到大排序
   - 将最小的两个权重做成一棵子树，将其放入权重排序中
   - 再取最小的两个权重做成子树，重复进行该过程，直到整个树建成