# 数据结构笔记

### 链表：

- List：线性表（每个元素的类型必须相同）——list基本操作与java中ArrayList基本相同
- simple array implementation of list——insert/removing
- Linked List——在java中由引用来使用link(link中的remove直接改变指针的指向即可)

![1570868249592](数据结构笔记.assets/1570868249592.png)

listnode 代码

![1570868361254](数据结构笔记.assets/1570868361254.png)

linkedListItr 链表游标——当前指针指向

![1570868563569](数据结构笔记.assets/1570868563569.png)

linkedList类只含有一个全局变量，为header，若为带表头节点，则header指向表头节点，若为不带表头节点，则header指向第一个数据节点

通过游标遍历单链表：

![1570868832275](数据结构笔记.assets/1570868832275.png)

双向链表：每个节点有两个指针，一个指针指向上一个节点，一个指针指向下一个节点，能够平均提升一倍的速度，但增加内存消耗

![1570870319222](数据结构笔记.assets/1570870319222.png)

循环链表：最后一个指针指向第一个节点

![1570870769200](数据结构笔记.assets/1570870769200.png)

##### 约瑟夫问题：

循环单链表=>每走m个next则将所在的次序退出，且输出该节点的序号=>到最后一个节点时结束

##### 多项式表示方法：

1. 用数组表示，每个数组单元的Index为多项式的次方，里面的值为多项式该次方的系数

   加法：

   ![1571042202701](数据结构笔记.assets/1571042202701.png)

   乘法：

   ![1571042225921](数据结构笔记.assets/1571042225921.png)

2. 用链表表示

   加法操作：

   ![1571042697280](数据结构笔记.assets/1571042697280.png)

##### 静态链表：

链表的连接方式由程序员管理（管理内存所有空间）

![1571045981417](数据结构笔记.assets/1571045981417.png)

- 初始化：将所有数据块串成单链表
- 分配内存：分配内存给对象后，将分配的内从从单链表中去除

##### 基数排序：

先把个位排序，通过链表储存，先进先出后，再把十位排序，把百位排序（同样方法），完成最终排序

![1571046777151](数据结构笔记.assets/1571046777151.png)

### 栈：

#### 单链表：尾部为栈底，头部为栈顶

![1571292764132](数据结构笔记.assets/1571292764132.png)

pick操作，取出数据，删掉top数据

![1571293099675](数据结构笔记.assets/1571293099675.png)

#### 数组实现栈：

![1571293233633](数据结构笔记.assets/1571293233633.png)

- 当有两个栈时，可以用同一块内存空间来放两个栈，一个起点为数组0位，一个起点为数组末端

#### 应用：括号matching 

基本逻辑为将左括号先push进栈中，然后遇到右括号时，将最近的一个左括号和此右括号进行匹配，匹配完即可

![1571296006155](数据结构笔记.assets/1571296006155.png)

#### 应用：expression evaluation

- 中缀表达式和后缀表达式：操作符出现在操作数的中间和末尾

- 后缀表达式，不需要写括号，可直接通过栈处理

- 遇到操作数就直接进栈，遇到后缀操作符就取出两个值计算，计算完了之后再进栈

  ![1571297779697](数据结构笔记.assets/1571297779697.png)

- 中缀表达式怎么转后缀表达式：

  ![1571297841673](数据结构笔记.assets/1571297841673.png)

  ![1571297866713](数据结构笔记.assets/1571297866713.png)
  
  （遇到操作数直接输出而遇到操作符不输出是因为操作符的另一半还没有被扫描到）
  
  （对于'('如果在栈中，则优先级为低优先级（为了防止提早弹出），但如果‘（’为当前符号，则为高优先级（防止栈中符号弹出））
  
  ![1571646452649](数据结构笔记.assets/1571646452649.png)
  
  （对于所有的‘）’都弹到知道遇到‘（’，如果不是的话则比较优先级选择是否弹出，‘（’有两个优先级，然后直到当前的符号的优先级大于栈顶的优先级，再将最后pop出的栈顶元素压栈，当前元素压栈）
  
  

### 队列：

#### 队列的进队与出队：

- 出队：back=back+1 front=front+1都是O（1）的复杂度

- ![1571647205682](数据结构笔记.assets/1571647205682.png)

  将数组变为一个圈，实现方法为：

  ![1571647274053](数据结构笔记.assets/1571647274053.png)

#### 应用：队列打印杨辉三角

![1571650055480](数据结构笔记.assets/1571650055480.png)

（基本逻辑为：保证每一行的数都进入，然后打印出下一行的值，同时将下一行的值储存进队列中，最后打印成整个三角）

（不用队列实现时直接用二维数组实现，每一行的某个数字由上一行的对应数字相加而来）

#### 应用：路径寻找

主要分为两个过程，第一个过程为从a开始寻找到b的路径，按照到a的距离标号，然后从b开始回溯，每一次都找标号更小的位置

![1571651888469](数据结构笔记.assets/1571651888469.png)

![1571651971184](数据结构笔记.assets/1571651971184.png)

基本逻辑为：不断的在队列当中增加格子，当一个格子的所有四个方向已经全部被搜索完之后，删除队列中的该格子，然后再将视角换位下个队列中的格子，直到到达最后的终点

![1571651983491](数据结构笔记.assets/1571651983491.png)

![1571651997793](数据结构笔记.assets/1571651997793.png)

### 树：

#### 定义：

空树/树根+子树

degree of the node:the children is has

degree of the tree:the maximum of the degree of node in the tree

leaf/branch:the degree is 0/not 0

level:the root :0 		the elelment:the level of its parent +1

depth of the tree:the maximum of the level

#### Binary tree:

根节点+每个节点有左树和右树

##### 二叉树性质：

1. 二叉树有N个节点的时候，必然有N-1条边
2. 二叉树的第i层最多有2的i次方个节点
3. 二叉树高度为h，最少的节点数为h+1,最多的节点数为2<sup>h+1</sup>-1
4. 二叉树的叶的个数为n，二叉树中度为2的节点个数为n<sub>2</sub>,则有n=n<sub>2</sub>+1
5. 如果一个二叉树含有N个节点，高度最多为N-1,最少为[log<sub>2</sub>(n+1)]-1

##### 满二叉树：

高度为h时，节点数为2<sup>h+1</sup>-1

满二叉树标号：从高到低，从左到右递增

##### 完全二叉树：

对于满二叉树从标号的最后开始删除节点，得到的树为完全二叉树

###### 性质：

1. 完全二叉树中，对于任意i>0，其父节点的标号为[(i-1)/2]
2. 对于一个节点，其左子节点的标号为2i+1，如果2i+1>=n，则没有左子节点

##### 二叉树的实现：

1. 数组实现完全二叉树：按照标号储存进数组（调用左子节点和右子节点是通过2i+1,2i+2）

2. 非完全二叉树：在完全二叉树的表示中空出对应的节点

3. 链表表示二叉树

   ![image-20191028165825988](数据结构笔记.assets/image-20191028165825988.png)

##### 二叉树的基本实现：

![image-20191028173728513](数据结构笔记.assets/image-20191028173728513.png)

###### 二叉树创建：

![image-20191028173803601](数据结构笔记.assets/image-20191028173803601.png)

###### 遍历二叉树：

<img src="数据结构笔记.assets/image-20191028173902893.png" alt="image-20191028173902893" style="zoom:80%;" />

VLR,LVR,LRV（递归访问）

preorder,inorder,postorder，level order

preorder:

<img src="数据结构笔记.assets/image-20191028175002457.png" alt="image-20191028175002457" style="zoom: 33%;" />

inorder:

<img src="数据结构笔记.assets/image-20191028175033869.png" alt="image-20191028175033869" style="zoom:33%;" />

postorder类似

level order：

如果按数组方式实现：则直接下标递增再访问即可

如果按链表实现队列：FIFO队列，上一层先进入，在下一层使用时调用上一层的子节点，再将上一层节点排出，下一层节点进入

<img src="数据结构笔记.assets/image-20191028175533974.png" alt="image-20191028175533974" style="zoom:67%;" />

使用非递归方法实现中序遍历：

基本逻辑为：直到最左边的左子树为空的时候对于该节点，输出它的值，然后p调用他的右子树，重复这一过程。

![image-20191031141426008](数据结构笔记.assets/image-20191031141426008.png)

使用非递归方法使用后序遍历：

基本逻辑为：P不为空时，一直将p导入进p的左子树，直到左子树为空，判断这个节点是不是右子树遍历完才回来的，如果是，则处理掉这个节点，同时调用他的上一个节点，直到上层节点的该节点是从左子树返回的，再将p指为其右子树，并将该节点设成tag为一。

![image-20191031142400612](数据结构笔记.assets/image-20191031142400612.png)

###### 如何建立二叉树：

- 利用先序，中序唯一构造二叉树

  ![image-20191031145121617](数据结构笔记.assets/image-20191031145121617.png)

- 利用二叉树的广义表示来构造一棵二叉树

  ![image-20191031145143547](数据结构笔记.assets/image-20191031145143547.png)

- 利用二叉树的后缀表示来表示一棵二叉树

  ![image-20191031145201289](数据结构笔记.assets/image-20191031145201289.png)



通过先序遍历和中序遍历的字符串构建二叉树：

- 基本逻辑为：通过先序遍历串确定树根，然后将t的左子树进行递归，将t的右子树进行递归
- 通过先序遍历和后序遍历/中序遍历和后序遍历也可以构建二叉树
- 通过这些方式构建的二叉树可能不唯一

![image-20191104161827611](数据结构笔记.assets/image-20191104161827611.png)

#### 二叉树应用

##### 树的储存方式：

- 广义表示法为括号中为其子节点
- 双亲表示法为一个元素的element的值为其父节点
- 左子女——右兄弟表示法为左节点即为其子节点，其height加一，右节点为平行节点

![image-20191104163110382](数据结构笔记.assets/image-20191104163110382.png)

##### 左子女右兄弟表示法的实现：

添加节点

遍历到其父节点，如果其父节点没有有左节点，则将该节点添加到其左节点，如果其父节点有左节点，则将从左节点开始沿着右节点走，直到最后，添加该节点

![image-20191104163935056](数据结构笔记.assets/image-20191104163935056.png)

##### 创建多棵树：

先将各个树通过“左子女——右兄弟”的表示方法排列，再将其通过根节点的右节点联系起来

##### 树的遍历：

1. 深度优先遍历

   - 先序优先遍历

   - 后序优先遍历（后序遍历的顺序和将该树转化为左子女右兄弟之后的二叉树的中序遍历顺序相同）

2. 广度优先遍历

   宽度有限：先将每一层的所有节点遍历完，再深入下一层

##### 森林的遍历：

将森林转化为左子女右兄弟的二叉树，然后遍历二叉树

![image-20191104165818571](数据结构笔记.assets/image-20191104165818571.png)

##### Thread Tree：线索化树

希望给节点一个额外的数据，直接指向中序遍历或者先序遍历的下一个节点，不需要用递归实现

- n个节点有2n个链域，且实际使用的只有n-1个链域

- 将右节点为null的设为中序遍历下一个节点的指针，左节点为null的设为中序遍历上一个节点的指针

- 需要标记——是原节点的指针还是中序遍历的指针（增加标记域）

  ![image-20191104172658989](数据结构笔记.assets/image-20191104172658989.png)

- 中序线索化树的遍历：如果有线索，就根据其线索走，如果没有线索，则找其右节点的最左节点即可

  ![image-20191104173719258](数据结构笔记.assets/image-20191104173719258.png)

  ![image-20191104173745799](数据结构笔记.assets/image-20191104173745799.png)

- 对于已知二叉树构建中序遍历线索树

  将其通过中序遍历，但要保留一个pre游标，游标中始终为该节点的中序遍历前一个节点的指针，当左节点为null时，填充pre

##### 霍夫曼树：

1. 增长数的概念
   - 使二叉树的所有节点度数为2，新增加的全为叶节点，新增加的全为外节点，原来的节点全为内节点
   - 外通路的长度：根节点到每个叶节点的长度的总和
   - 内通路的长度：根节点到原树的长度的总和
   - 带权重的通路长度：每个节点可以设置权重，再来算通路的总长度
   
2. 霍夫曼树的目标：构建一个加权的外通路长度最短的树（给了叶节点的数量，对于一棵完全二叉树，其所有节点的数量是固定的）

3. 霍夫曼树的算法：
   - 先将权重从小到大排序
   - 将最小的两个权重做成一棵子树，将其放入权重排序中
   - 再取最小的两个权重做成子树，重复进行该过程，直到整个树建成
   
4. 霍夫曼编码

   ![image-20191111162329415](数据结构笔记.assets/image-20191111162329415.png)

   ![image-20191111163212420](数据结构笔记.assets/image-20191111163212420.png)

   译码过程为直接对于译码树开始解释，走到最后的叶子后，再开始下一个字符的译码（不需要做修饰）

### 搜索树：

#### Binary Search Tree

##### 二叉搜索树满足条件：

- 每个节点的key值是不相同的
- 每个节点左子树的每个key值比树根小，右子树的每个key值比树根大

##### Indexed binary search tree:

每个携带特殊内容：左子树的节点数+1，其实即为在整个二叉树中的Index大小

##### 查找算法:

每次去比较要查找的节点和该节点的值的大小

![image-20191111174450336](数据结构笔记.assets/image-20191111174450336.png)

##### 插入算法：

- 如果二叉树为空树，直接往节点上增加
- 如果二叉树不为空树，递归查询（比树根的值大插入左子树中，比树根的值小插入右子树中）

##### 删除算法：

- 删除节点是树叶，则直接删除
- 删除节点有一个子节点，则用其子节点直接替代
- 删除节点有两个子节点，则用其左子树的最右边一个节点代替它（即刚好大于它的一个节点）

##### 复杂度

（时间复杂度主要由树高判断）

二叉搜索树的形状不能够自主控制：

- 时间复杂度可能变成O(n)，如果二叉树的形状为一条直线
- 时间复杂度可能变成O(log<sub>2</sub>n)，如果二叉树的形状为一棵平衡的树

#### AVL树（自平衡二叉树）

##### 定义

- 二叉搜索树
- 任意节点的左子树和右子树高度差不超过1

##### 数据结构

其中有一个平衡因子——高度差

![image-20191114141557660](数据结构笔记.assets/image-20191114141557660.png)

时间的复杂度也是log<sub>2</sub>级别的

##### AVL树保持平衡的方法：

1. 左旋：

   ![image-20191114142329988](数据结构笔记.assets/image-20191114142329988.png)

2. 先右旋，再左旋

   ![image-20191114142740927](数据结构笔记.assets/image-20191114142740927.png)

- 破坏平衡性的节点添加如果在树的外沿，就需要旋转一次/如果在树的中间，就需要旋转两次

- 调整的方式是从最小不平等子树中，通过逐个回溯的形式做左旋或者右旋调整）

- 旋转的方式是往下看两层来判断是内侧还是外侧

##### AVL插入

基本逻辑为：递归插入在左子树上，此时左子树应该为平衡的，然后看根节点，如果根节点的左子树比右子树的高度差为2，则如果插入在左子树的左子树上，单旋，如果插入在左子树的右子树上，双旋

![image-20191114144700823](数据结构笔记.assets/image-20191114144700823.png)

##### AVL删除

- 删除叶节点

  1. 如果删除叶节点后该子树的高度会不会减一，则不需要调整
  2. 如果删除之后子树的高度加一次，因此可能会影响该节点的根节点到树的根节点等一系列的节点子树高，因此需要进行一系列的调整（回溯保持平衡）

- 删除根节点

  1. 首先根据二叉树的删除做替换
  2. 原子树相当于删除了一个叶节点

  

#### B-trees

##### m路搜索树

每一个节点放不超过m-1个关键码的值，关键码之间两两有一个指针，因此有m个指针

![image-20191114151650897](数据结构笔记.assets/image-20191114151650897.png)

每个节点中的关键码值储存为——从k<sub>1</sub>到k<sub>p</sub>从小到大排列

![image-20191114152020119](数据结构笔记.assets/image-20191114152020119.png)

###### 插入

直接插入，如果满了之后则添加一个key的子树

###### 删除

直接删除一个key值，如果此时要删掉一个叶节点，则删除该叶节点;如果此时要删除一个根节点，则删除该根节点并将其左子树的最大值或者右子树的最大值替代原位置

最多节点数：

![image-20191114152537193](数据结构笔记.assets/image-20191114152537193.png)

最少节点数：h

##### B树

###### 性质

在m路的搜索树上满足：

1. 所有的外节点在同一层
2. 根节点至少有两个key值
3. 每个节点最少有（m/2）向上取整个key值

###### 二阶B树

必然是一棵满二叉树

###### 三阶B树

每个节点中必然含有一个key值或者两个key值

- 外节点树=B树总key值数加1

###### 查询

和m路搜索树的查询算法相同

###### 节点个数：

最少情况——节点最少，高度最高的情况（第一层仅有两个key值，其余层节点数最少）

![image-20191114154355497](数据结构笔记.assets/image-20191114154355497.png)

Key值为n时，二叉树的高度范围：

![image-20191114154757768](数据结构笔记.assets/image-20191114154757768.png)

###### 插入

1. 先做一次查询，找到插入的位置

   B树的叶节点：最下层的节点的key值

2. （当B树的节点key值不满时）直接插入

3. （当B树的节点key值满后）拆成两个节点插入，即将B树的该节点裂成两个节点，然后上一层增加一个关键码值，使得叶节点有多个

4. 当在插入的过程中需要增加树根数时，处理方法为将树根再次拔高，增加树的高度，形成一个新的树根

   ![image-20191118162630430](数据结构笔记.assets/image-20191118162630430.png)

   ![image-20191118162639842](数据结构笔记.assets/image-20191118162639842.png)

算法分析

h（读取h个节点）+2s（将节点分开的次数）+1（写新的节点）

###### 删除

1. 删除叶节点key值

   - 如果删除key值后叶节点的key值过少，则向相邻节点（借）
   - （借）的过程为，将最大的key值拉上去，将上节点的key值拉下来，如果相邻节点也无法借节点，则将其与相邻节点合并（父节点的一个key值被拉下来）
   - 对于B树的删除过程需要注意的是，B树只进行根的上升或者下移，不随便删除叶节点或者改变中间的结构，因此如果B树中一个根节点被拉下到下一层，该根节点没有了key值，此时的情况应该相当于删除了中间节点的key值，用左边子树的最大子树做替换或者右边子树的最小子树做替换
2. 删除中间节点的Key值

   取左边子树的最大key值来替换被删掉的key值，其余的过程相当于删掉一个叶节点的key值


### Hashing

#### 主要思路

散列表的设计目标：存取数据加快

存取复杂度：

![image-20191118165738236](数据结构笔记.assets/image-20191118165738236.png)

##### 方法：

- 做一次散列函数
- 如果没有冲突解决，即将数据存到散列函数的结果数组中

##### 冲突基本概念：

散列表的一格中有多个数据

装填因子：n（数据总数）/b（散列表长度）

装填因子越大，越可能发生冲突

#### hash函数

##### 取余法

H（key）=key%M

M一般取基本区长度的最大质数:取偶数时冲突率比较大（如果key有一些特殊性质）

##### 平方取中法

H（key）=key<sup>2</sup>的中间部分

![image-20191118173916100](数据结构笔记.assets/image-20191118173916100.png)

取尽量不易冲突且覆盖所有散列表的部分

##### 乘法杂凑函数

![image-20191118174006957](数据结构笔记.assets/image-20191118174006957.png)

乘一个比较非常见的数，并取其小数部分

M为表长

##### 字符串hash函数

1. 将字符串的ascii码相加，然后对hash散列表的大小取模

2. 使用多项式的方式处理ascii码

   ![image-20191118174944665](数据结构笔记.assets/image-20191118174944665.png)

#### 冲突解决

##### linear probing 

仍然维持散列表是一个线性列表，当原位置被占时，直接在延后位置存

![image-20191119164543618](数据结构笔记.assets/image-20191119164543618.png)

linear probing代码表示

- 由两个数组表示：ht和empty，ht中有一个key E，empty有一个标志位 k（可以通过对象来扩展数组，也可以用两个数组来表示）
- 当ht的相应位置元素不有效时，empty的相应位置为true

线性探测快速探测容易发生堆积

##### Quadratic probing

二次探测：在探测时，如果有冲突发生，则向后探测1,4,9...等位置，即向后探测平方项的探测，防止堆积过于密集造成复杂度过高

java实现方式：

![image-20191125163203906](数据结构笔记.assets/image-20191125163203906.png)

寻找元素：

![image-20191125164803425](数据结构笔记.assets/image-20191125164803425.png)

但是如上代码会在哈希表为full且元素不在哈希表中时出现死循环

##### double hashing 

当第一个散列函数冲突时，即取第二个散列函数（使得两个散列函数的重复程度很低）

##### rehashing

一般来说散列表很少放满（很多空间浪费），但时间复杂度理论上降低到O（n）

rehashing的过程：

![image-20191125165640693](数据结构笔记.assets/image-20191125165640693.png)

当原数组快满时，增加散列表的容量

##### Seperating chaining

<img src="数据结构笔记.assets/image-20191125171246231.png" alt="image-20191125171246231" style="zoom: 33%;" />

在散列表的数组中，每个数组为一个链表的开头指针来实现冲突的解决

### Priority queue

每个元素都有一个优先级的队列，元素进队时有一个优先级，出队时出优先级最小/大的元素

#### Linear list representation

- 每次加入时在末端加入元素O(1)
- 每次取数据时复杂度为O（n），相当于做一轮Max

#### heap

##### 定义

- 完全二叉树
- 有最大堆和最小堆
- 对于最大堆有：二叉树的每个节点都对应优先级，每个节点的优先级都比子树的优先级大或相等，最小堆类似

堆保存成一个数组的形式，完全二叉树在数组中的储存形式为广度优先

##### 插入操作

先将数据插入到二叉树的最后，然后跟父节点比，如果比父节点大，就上浮（迭代进行该操作）

![image-20191125173703812](数据结构笔记.assets/image-20191125173703812.png)

代码操作如下，具体逻辑其实为和父节点比较，在数组中即为i和i/2比较然后判断是否交换

![image-20191125174040471](数据结构笔记.assets/image-20191125174040471.png)

##### 删除操作

将根节点拿掉，然后将数组的最后一个元素来替换根节点，然后进行下滤（先比较左子节点和右子节点，将节点和比较大的节点进行替换，递归进行此操作直到该节点重新形成这个堆）

![image-20191125174333558](数据结构笔记.assets/image-20191125174333558.png)

![image-20191125175220591](数据结构笔记.assets/image-20191125175220591.png)

##### 初始化堆

完全二叉树的最后一个节点为n，开始下标为n/2，从2/n到1的每个节点分别进行下滤

![image-20191125180034717](数据结构笔记.assets/image-20191125180034717.png)初始建堆算法：

- 从一个数组初始化成堆：n个节点，高度为log<sub>2</sub>n，其算法复杂度为O(n)
- 自建堆：使用插入的方法，对每个进入的数据插入在堆中，做一次上滤，其复杂度为O(nlogn)

#### Application of priority queue

##### 堆排

实现从小到大的数组排序，通过下滤将堆排成最大堆的形式，将其树根输出，并用最下面的堆元素代替树根，剩余的堆重复“树根输出，代替树根”的操作，最后形成了一个从小到大的数组

- 初始化

  ![image-20191128143217878](数据结构笔记.assets/image-20191128143217878.png)

- 迭代排序

  ![image-20191128143227771](数据结构笔记.assets/image-20191128143227771.png)

堆排不稳定:相同值的元素在排序后的相对位置会发生变化

##### 选择问题

在N个元素的数组中挑选第k大的元素

1A：将N个元素进行排序，然后选取需要的元素：O（n）

1B：

- 将K个元素放入数组，排序
- 将数组的其他元素与数组中的元素进行比较，如果大于k中最小的元素，则替换掉最小的元素并排在合适的位置，重复直到数组中元素全都进行完比较
- 最后第K大的元素即为k数组中最小的那个数
- O（nk）

6A：

使用堆

- 将N个元素建最大堆，O(N)
- 删除最大元素，重复K次，O（K*logN）
- 总时间复杂度为O（N+K*logN）

6B:

- 读入前K个元素，建立最小堆
- 将后续的所有元素跟最小堆的数据比较，如果比树根小，则舍弃，如果比树根大，将该元素替换树根，同时进行一次下滤,O(logk)
- O(K+（N-K）logk)

### The disjoint set

#### 等价类：

##### 定义：

![image-20191128151001847](数据结构笔记.assets/image-20191128151001847.png)

数据结构：等价关系和划分

##### 等价类操作

- combine(a,b)：合并两个等价类
- find：找到元素在哪个等价类中（即找根节点的下标）

##### 并查集应用：双亲表示法

![image-20191128152522231](数据结构笔记.assets/image-20191128152522231.png)

使用数组表示：

- 森林中每一棵树表示并查集
- 若为树根，则下标为0
- 其余节点下标为其父节点的下标

算法复杂度:

- union:O(1)

  ![image-20191128153608378](数据结构笔记.assets/image-20191128153608378.png)

- find:O(h)

  worst case:

  ![image-20191128153633080](数据结构笔记.assets/image-20191128153633080.png)

改善方法：

- 在进行union操作时，每次都将节点数少的结合到节点数多的树下
- 根节点的下标为负数，其绝对值为树的高度
- find-path compression 将find中遍历的节点挂到树根上

### Graph

#### definition

- 有向图
- 无向图

图中边的数量最多为n(n-1)/2

**degree**：和顶点连接的边的总数

- 无向图为连接的点数
- 有向图分为indegree和outdegree
- edge数*2=所有度数之和

**path**:表示成顶点的序列（每两个相邻的节点在之间有边相连）

**simple path**：路径中的顶点不能重复（起点和终点可以，此时为simple cycle）

**connected graph**：任意两个顶点之间连通的图（任意图都可以有极大连通子图）

**strongly conneted**：对于两个连通的节点，可到达性是双向的

**strongly connected component 强连通分量**：对于一个不是强联通的图的最大强连通子图

**network**：连通的加权图

**spanning tree**：对于一个连通图的极小连通子图（再去掉任意一个节点，都不再连通）

#### 物理实现

##### 邻接矩阵

![image-20191202165004600](数据结构笔记.assets/image-20191202165004600.png)

- 无向图的连接矩阵为对称矩阵
- 节点的度数为将某一列或者某一行的1的个数加起来（有向图分别对应indegree 和outdegree）
- 对于加权图的矩阵，有边就记录权重，没有边记为一个标记即可
- 在矩阵中，可通过两个Index来确定一条边，边有权重或者边不存在

方法实现：

- 构造函数：连接矩阵清零
- 求顶点V的第一个领连接点的位置：遍历顶点V对应的行，第一个非零值在返回其所在的列

（连接矩阵的空间复杂度固定为n<sup>2</sup>,因此空间复杂度较大）

##### 邻接链表

无向图邻接表

![image-20191202172211095](数据结构笔记.assets/image-20191202172211095.png)

- 无向图的顶点的度数即为顶点对应的单链表的长度

有向图邻接表（只标出边）

![image-20191202172643642](数据结构笔记.assets/image-20191202172643642.png)

- 只标入边的邻接表一般称为逆邻接表

构造函数：

![image-20191202174259405](数据结构笔记.assets/image-20191202174259405.png)

给出顶点V的第一个邻接点的位置：

![image-20191202174448936](数据结构笔记.assets/image-20191202174448936.png)

##### 邻接多重表：

为了节省空间，在无向图中为了节省空间，每一个边都只对应一个节点（每个path都有两个节点）

![image-20191202175127998](数据结构笔记.assets/image-20191202175127998.png)

有向图的每个节点都有第一条入边，第一条出边开始

![image-20191202175444659](数据结构笔记.assets/image-20191202175444659.png)

#### 遍历

##### 深度优先遍历

从一个节点开始遍历，将节点设置为被遍历过，然后对节点的所有邻接节点做递归

对于每一个顶点建立一个visited[]数组，来储存该顶点是否被访问过的状态

![image-20191209162142808](数据结构笔记.assets/image-20191209162142808.png)

算法复杂度：

- 邻接表表示：O(n+e)
- 邻接表矩阵表示：O（n²）

##### 广度优先遍历

<img src="数据结构笔记.assets/image-20191209163753711.png" alt="image-20191209163753711" style="zoom:50%;" />

对于最开始的一个节点，一层一层访问所有的节点

- 在算法表示时需要一个visited数组表示顶点是否被访问过，需要一个队列来表示这一层正在进行遍历的节点和下一层要遍历的节点
- 对于每一个节点，出队列的时候，将跟其相连的所有节点全都输入进入队列

![image-20191209164057862](数据结构笔记.assets/image-20191209164057862.png)

算法复杂度：

- 邻接表：O(n+e)
- 邻接矩阵：O(n<sup>2</sup>)

##### 非连通图遍历

- 对于一个图来说，当其不连通时，对一个节点进行遍历，能够遍历所有的连通分量
- 遍历的方式为，对一个节点进行遍历，遍历完所有连通分量后，再从没有被遍历的节点进行遍历，再遍历所有连通分量，知道所有节点被遍历完

#### 最小生成树

##### 生成树

从图中的任何一个顶点出发，做遍历图的操作，生成的图为G的生成树

- 每一种遍历的算法都对应一棵生成树
- 每棵生成树的边为顶点数-1
- 生成树的代价：生成树保留的边的权重之和

##### greedy 算法思想

只看当前解决办法中最好的解决单步问题，不顾以后的其他代价，最后由多个单步问题来解决最终问题

##### Kruskal 算法

###### 方法

每一步只加入一条边，这条边的权重最小且该边加入不会形成回路

![image-20191209172303960](数据结构笔记.assets/image-20191209172303960.png)

![image-20191209172347420](数据结构笔记.assets/image-20191209172347420.png)

###### 实现

取最小边：最小堆Heap

判断是否构成回路：并查集（将每个顶点看作一个并查集，当两个顶点连接时，将两个顶点的并查集合并，每个并查集可以表示一个连通分量，如果形成了回路，则改变连接的起点和终点都在一个并查集内）

- 先扫描一遍邻接矩阵，把所有的边建立成一个最小堆
- 判断两个顶点是否在同一个并查集内，如果在同一个并查集内则舍弃该边，如果不在，就把两个并查集连接在一起，同时将该边输入进最小生成树内

![image-20191209173813060](数据结构笔记.assets/image-20191209173813060.png)

算法复杂度：

![image-20191209174857208](数据结构笔记.assets/image-20191209174857208.png)

find算法复杂度分析：对于并查集来说，获取一棵树高为H的树，至少需要两棵树高为H-1的树并起来，对于并查集的所有节点数为N，树高最大为log<sub>2</sub>N

##### Prim算法

###### 实现

从一个顶点开始往外，展开形成一棵最小生成树

- 选择一个点作为起点
- 沿着起点往外长出最小生成树，每次长一条边，选择的边为当前能够到达的节点的边中最小的边，同时将该边连接的顶点加入并查集
- 形成最小生成树

其中一步如图，寻找最小的虚线边即可

![image-20191212142056926](数据结构笔记.assets/image-20191212142056926.png)

###### 算法分析

最坏情况下为所有的边都互相连接，此时算法分析如下

![image-20191212142710853](数据结构笔记.assets/image-20191212142710853.png)

###### 具体实现

![image-20191212143429928](数据结构笔记.assets/image-20191212143429928.png)

![image-20191212143449841](数据结构笔记.assets/image-20191212143449841.png)

对于lowcost中的边，比较一下当前lowcost里面相应边的值和现在连接到该点的边的值，如果到节点的边的权重变小，则更新掉lowcost里面的值

（找到到达一个点的最小的边的权重）

（避免重复进行比较，直接取最小的边的权重即可）

**过程：**

- 在lowcost[]中选中nearvex[]不为-1的边
- 将该点的nearvex值更新为-1
- 进行比较：lowcost[i]中的值取min{lowcost[i],Edge[v,i]}，即将生成树外的所有顶点i和新加入的顶点形成的边也并入lowcost中

![image-20191212150848948](数据结构笔记.assets/image-20191212150848948.png)

![image-20191212150905322](数据结构笔记.assets/image-20191212150905322.png)

算法复杂度：

![image-20191212151354879](数据结构笔记.assets/image-20191212151354879.png)

#### 最短路径

##### dijkastra算法：权值非负时从一个顶点到其他各节点

eg：固定起点V<sub>0</sub>,求从该点到其他所有点的最短路径

![image-20191212152445292](数据结构笔记.assets/image-20191212152445292.png)

###### 算法思想：

- 先得到与V<sub>0</sub>由一条边连接的所有顶点，这些边中最短的那一条边（此时该边就是V<sub>0</sub>到该点的最短路径）
- 将已经找到最短路径的所有顶点放到一个并查集中，在剩下的顶点中，将加入最短路径的该点进行更新查看现在能够到达的顶点路径是否变短
- 更新后的到不在并查集中的顶点的最短路径，取该点到并查集中

![image-20191212154838430](数据结构笔记.assets/image-20191212154838430.png)

###### 代码

- 对于矩阵进行初始化，第一个for循环确定距离原点为一条边的所有节点
- 进行迭代，每一次都找到所有可行路径的最短路径（这个最短路径需要是原点到一个顶点的可行路径的最短路径，因此需要更新，且为所有可行路径的最短路径）

![image-20191216161928789](数据结构笔记.assets/image-20191216161928789.png)

###### 算法分析：

![image-20191216162634481](数据结构笔记.assets/image-20191216162634481.png)

##### 贝尔曼—福特算法：权值为任意值的单源最短路径

###### 算法思想：

基本为构造所有方式来到达一个顶点的算法来计算最短路径（先枚举，再取最小值）

![image-20191216163513129](数据结构笔记.assets/image-20191216163513129.png)

![image-20191216163524144](数据结构笔记.assets/image-20191216163524144.png)

- 从第k步的最短路径距离到第k+1步，第k+1步路径即为从其他顶点经过k步的最小值再加上一步到达该顶点，再将这些顶点中最短的路径和k步到达的最短路径进行比较
- 迭代完所有的步长，然后选择最短路径即可

注意：

如果有负权值的回路，可以绕无穷次，再到其他地方（有负回路时最短路径无意义）

![image-20191216164315705](数据结构笔记.assets/image-20191216164315705.png)

###### 代码：

- 初始化dist和path（path中的顶点为倒数第二个顶点）
- 对于k步进行迭代，如果在k+1步中（遍历所有的第k步到达的节点的最短路径）出现了比k步更短的距离，则将距离更新

![image-20191216164722545](数据结构笔记.assets/image-20191216164722545.png)

##### floyed:权值非负的所有顶点的最短路径

1. 把有向图的每一个顶点作为原点，做一次dijkstra
2. 使用floyed算法

###### 算法思想：

- 使用邻接矩阵，将邻接矩阵更新为从一个点到另一个点的最短路径
- ![image-20191216165841918](数据结构笔记.assets/image-20191216165841918.png)
- 对于矩阵中的每一个值进行一次迭代，第一轮对于顶点1进行迭代，如果从顶点1绕更近，则取从顶点1绕的值，第二轮对于顶点2（此时的矩阵中的顶点2已是更新过的最短路径），依次类推

###### 算法实现:

![image-20191216172625609](数据结构笔记.assets/image-20191216172625609.png)

#### 活动网络

##### 拓扑排序:

对于一个活动网络，将其进行排序，其排序满足活动网络的偏序关系（能拓扑排序的网络没有环）

![image-20191216174359237](数据结构笔记.assets/image-20191216174359237.png)

###### 算法思想：

- 在图中任选一个入度为0的顶点，将其添加进拓扑排序的序列
- 在图中将该顶点删除，同时删除其所有的出边
- 重复选择一个入度为0的顶点

##### 用顶点表示活动的网络 AOV

###### 具体实现：

AOV网络通过邻接表来实现

数组count来存放每一个顶点的入度（建立入度为0的顶点栈，指针最开始指向入度为0的点，其余的count指向该点指向的点，删除该点之后指针指向数组中储存内容的顶点即可）

![image-20191216175443614](数据结构笔记.assets/image-20191216175443614.png)

###### 用AOV实现拓扑排序：

- 先进行初始化
- 选择入度为0的顶点（top位置），删除顶点，且将该顶点指向的其他所有顶点的入度全都-1

![image-20191216175930491](数据结构笔记.assets/image-20191216175930491.png)

##### 用边来表示活动 AOE

###### 具体活动eg

![image-20191223161642932](数据结构笔记.assets/image-20191223161642932.png)

- 活动可以同时进行
- 关键路径为从开始顶点到结束顶点的最长

###### 寻找关键活动的算法：

- 定义变量：

  - Ve[i]和VI[i]每个关键活动的最早发生时间（当前顶点到起点的最长路径）和最晚发生时间（总长度-当前顶点到终点的最长路径）
  - 如果一条边的最早开始时间和最晚开始时间相同，即为关键活动

- 求解算法

  - 先通过拓扑排序和逆拓扑排序进行排列

    ![image-20191223163835688](数据结构笔记.assets/image-20191223163835688.png)

  - 算出所有顶点的最早开始时间（当前顶点到原点的最短路径可由前驱顶点决定，可以先做一次拓扑排序）

  - ![image-20191223163320477](数据结构笔记.assets/image-20191223163320477.png)当前顶点的最晚开始时间，因为是到终点的最长距离，因此为总时间减去距离的最小值

- 代码实现：

  ![image-20191223164618134](数据结构笔记.assets/image-20191223164618134.png)

  ![image-20191223164629305](数据结构笔记.assets/image-20191223164629305.png)

### 排序算法

#### 概述：

- 内排序：对内存中n个对象进行排序

  外排序：内存放不下，还要使用外存的排序

- 稳定性：对于拥有多个关键码性质的对象，用某种方法排序后相对序列不变，则该方法为稳定的排序算法

- 算法分析：

  - 时间复杂度在于比较次数和移动次数
  - 所需要的附加空间

#### 插入排序

将前面的所有的对象排好序，再将后面插进来的对象放到相应的位置

##### 直接插入

![image-20191223165628400](数据结构笔记.assets/image-20191223165628400.png)

算法为：

每次从数组中取出来一个值，当该值到达数组中合适的位置时，即放置该元素

![image-20191223165914382](数据结构笔记.assets/image-20191223165914382.png)

插入排序如果原序列为顺序时，其算法复杂度为O（n），如果原序列为逆序时，其算法复杂度为O（n<sup>2</sup>）

##### 折半插入排序

折半查找操作为：取出一个数，如果后面的数比他大，则放在其后面，如果比他小，则放在其前面

![image-20191223172042036](数据结构笔记.assets/image-20191223172042036.png)

数据移动次数的复杂度仍然是n<sup>2</sup>

##### 希尔排序

- 取一个增量，按增量分组，对每一组进行插入排序或者其他排序方式
- 逐步减少增量，直到增量为1，即完成了所有的排序

![image-20191223172548855](数据结构笔记.assets/image-20191223172548855.png)



![image-20191223173026656](数据结构笔记.assets/image-20191223173026656.png)

算法复杂度大约为：n<sup>1.3</sup>

#### 冒泡排序

- 两两比较相邻的数字，将大/小的数挪到一段
- 每一轮能够将最大数/最小数排列到一端

![image-20191223173344181](数据结构笔记.assets/image-20191223173344181.png)

#### 快速排序

- 排序很多轮，每一轮中选择一个基准值，将比基准值小的放在左边，比基准值大的放在右边
- 使用递归的方式，在左边取基准值再进行快排，在右边取基准值进行快排

![image-20191223173612521](数据结构笔记.assets/image-20191223173612521.png)

##### 改进方式：

通过两个指针改善空间复杂度

取出基准值，则基准值的空间为空，右边的指针逐渐往左移，遇到比基准值小的数则放到基准值上，此时开始移动左边的指针，直到遇到比基准值大的值，放在右边指针指向的位置

两个指针相遇时停止

![image-20191223173915258](数据结构笔记.assets/image-20191223173915258.png)

##### 代码实现：

![image-20191223175746628](数据结构笔记.assets/image-20191223175746628.png)

不稳定的算法

##### **算法复杂度**

**时间复杂度**

最差的情况为数组为已经排序好的数组（因为选择的基准值在最小处，基准值在中间位置较为合适）

此时复杂度为O（n<sup>2</sup>）

平均复杂度为O(nlog<sub>2</sub>n):需要经过log<sub>2</sub>轮，每一轮复杂度为n

**空间复杂度**

需要用栈来储存基准值的指针

栈储存内容：

![image-20191223175244781](数据结构笔记.assets/image-20191223175244781.png)

##### 取基准值方法：

- 随机数生成
- 三数中值分割法

#### 选择排序

##### 直接选择排序

每一次选择关键码最大或者最小的数，经过n-1轮

##### 锦标赛排序

方法：

- 将两个两个元素进行比较，比较小的元素取出，再两两进行比较，直到产生最小的元素（此时建立了胜者树），然后输出
- 将最小值改为正无穷，然后在最小值的原线上进行新的比较，生成其他的最小值
- ![image-20191226140623091](数据结构笔记.assets/image-20191226140623091.png)

算法复杂度：

![image-20191226140717234](数据结构笔记.assets/image-20191226140717234.png)

##### 堆排

- <img src="数据结构笔记.assets/image-20191226141401150.png" alt="image-20191226141401150" style="zoom:50%;" />
- 不稳定的算法，复杂度为nlogn

代码：

![image-20191226141449926](数据结构笔记.assets/image-20191226141449926.png)

![image-20191226141458407](数据结构笔记.assets/image-20191226141458407.png)

#### 归并排序

思想：将数组运用排序的算法，如果前一半和后一半已经排好序，运用较快的方法排好整个数组

（关键在于将排好序的数组归并成一个合起来的数组）

方法：

- 将数组两组两组分开，直到分为两个一组，进行比较，然后进行归并
- 归并过程为使用三个下标，三个指针指向的数字中最小的进行拷贝，然后该指针向前，拷贝形成的总数组为最终的数组

![image-20191226142001186](数据结构笔记.assets/image-20191226142001186.png)

代码：

迭代实现：

- 归并过程

  ![image-20191226143110811](数据结构笔记.assets/image-20191226143110811.png)

- 排序代码：

  通过Len控制每个数组的大小，len为2时两个两个进行比较，len逐渐乘2直到len>=currentsize时，使用一个for循环将templist拷贝回list，完成排序（Mergepass为实现微观归并的方法）

  ![image-20191226143131236](数据结构笔记.assets/image-20191226143131236.png)

  mergepass过程需要注意当最后可能出现了一个组的size不够len的情况

  ![image-20191226144528700](数据结构笔记.assets/image-20191226144528700.png)

递归实现：

![image-20191226144749419](数据结构笔记.assets/image-20191226144749419.png)

算法分析：

稳定的算法

<img src="数据结构笔记.assets/image-20191226143847743.png" alt="image-20191226143847743" style="zoom:50%;" />

#### 排序小结：

![image-20191226145003029](数据结构笔记.assets/image-20191226145003029.png)



## 期末重点

算法分析：

- 算法分析定义
- 表示法
- 写出程序复杂度

排序算法







